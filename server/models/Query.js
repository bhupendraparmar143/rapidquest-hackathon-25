/**
 * Query Model
 * Represents an audience query from any channel (email, social media, chat, community)
 * Includes auto-tagging, priority detection, assignment, and status tracking
 */

const mongoose = require('mongoose');

const querySchema = new mongoose.Schema({
  // Basic Information
  subject: {
    type: String,
    required: true,
    trim: true
  },
  content: {
    type: String,
    required: true
  },
  channel: {
    type: String,
    required: true,
    enum: ['email', 'social_media', 'chat', 'community', 'phone'],
    index: true
  },
  
  // Sender Information
  senderName: {
    type: String,
    required: true,
    trim: true
  },
  senderEmail: {
    type: String,
    trim: true,
    lowercase: true
  },
  senderId: {
    type: String, // External ID from the channel (e.g., Twitter handle, chat ID)
    index: true
  },
  
  // Auto-tagging (generated by tagging service)
  tags: [{
    type: String,
    enum: ['question', 'request', 'complaint', 'compliment', 'feedback', 'technical_issue', 'billing', 'other'],
    default: []
  }],
  primaryTag: {
    type: String,
    enum: ['question', 'request', 'complaint', 'compliment', 'feedback', 'technical_issue', 'billing', 'other']
  },
  
  // Priority Detection (generated by priority service)
  priority: {
    type: String,
    enum: ['low', 'medium', 'high', 'urgent'],
    default: 'medium',
    index: true
  },
  priorityScore: {
    type: Number,
    min: 0,
    max: 100,
    default: 50
  },
  
  // Assignment & Status
  status: {
    type: String,
    enum: ['new', 'assigned', 'in_progress', 'resolved', 'closed', 'escalated'],
    default: 'new',
    index: true
  },
  assignedTo: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    default: null
  },
  assignedTeam: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Team',
    default: null
  },
  
  // Timestamps
  receivedAt: {
    type: Date,
    default: Date.now,
    index: true
  },
  assignedAt: {
    type: Date,
    default: null
  },
  firstResponseAt: {
    type: Date,
    default: null
  },
  resolvedAt: {
    type: Date,
    default: null
  },
  closedAt: {
    type: Date,
    default: null
  },
  
  // Response Time Tracking
  responseTime: {
    type: Number, // in minutes
    default: null
  },
  resolutionTime: {
    type: Number, // in minutes
    default: null
  },
  
  // Escalation
  isEscalated: {
    type: Boolean,
    default: false
  },
  escalatedAt: {
    type: Date,
    default: null
  },
  escalationReason: {
    type: String,
    default: null
  },
  
  // History & Notes
  history: [{
    action: String,
    performedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    timestamp: {
      type: Date,
      default: Date.now
    },
    notes: String
  }],
  
  // Additional Metadata
  metadata: {
    type: Map,
    of: mongoose.Schema.Types.Mixed,
    default: {}
  }
}, {
  timestamps: true // Adds createdAt and updatedAt automatically
});

// Indexes for efficient querying
querySchema.index({ status: 1, priority: -1, receivedAt: -1 });
querySchema.index({ assignedTo: 1, status: 1 });
querySchema.index({ tags: 1 });
querySchema.index({ channel: 1, receivedAt: -1 });

// Virtual for calculating time since received
querySchema.virtual('timeSinceReceived').get(function() {
  return Math.floor((Date.now() - this.receivedAt) / (1000 * 60)); // in minutes
});

// Method to update status and log history
querySchema.methods.updateStatus = function(newStatus, userId, notes = '') {
  this.status = newStatus;
  this.history.push({
    action: `Status changed to ${newStatus}`,
    performedBy: userId,
    notes: notes
  });
  
  // Set timestamps based on status
  if (newStatus === 'assigned' && !this.assignedAt) {
    this.assignedAt = new Date();
  } else if (newStatus === 'resolved' && !this.resolvedAt) {
    this.resolvedAt = new Date();
    this.resolutionTime = Math.floor((Date.now() - this.receivedAt) / (1000 * 60));
  } else if (newStatus === 'closed' && !this.closedAt) {
    this.closedAt = new Date();
  }
  
  return this.save();
};

// Method to assign query
querySchema.methods.assign = function(userId, teamId, assignedBy) {
  this.assignedTo = userId;
  this.assignedTeam = teamId;
  this.status = 'assigned';
  this.assignedAt = new Date();
  this.history.push({
    action: 'Query assigned',
    performedBy: assignedBy,
    notes: `Assigned to user ${userId}`
  });
  return this.save();
};

module.exports = mongoose.model('Query', querySchema);


